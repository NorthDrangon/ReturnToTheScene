# ReturnToTheScene
 一本开源技术书籍

# 序言
在这里，我将会记录一系列从真实的事故现场总结的项目研发经验。课堂中学习其实最多只能汲取真理的一半内容，而另一半的真理，必须深入到最真实的现场，去看，去触摸，去实践然后才能获得。纸上得来终觉浅，只有深入到最前沿的项目现场，观察产品运转过程中最细微的细节，理解每一个设计背后最细致的考量，然后才能真正理解所学的知识。
我写作这本书的目的，就是期望分享我多年来，在项目现场的见闻，记录下那些即使是顶尖工程师也可能犯下的错误，让读者看到那些只有亲历者才会掌握的经验，看到优秀的工程师如何解决那些棘手的问题，避免灾难性的事故。 
为了确保这本书的内容可以达到这个目的，我为这本书定下了下面三个品控标准： 
1，真问题：写入本书的每一个案例，都必须是真实生产环境中，造成过真实损失的真实事故。那种一百年都没人用的语法糖或是奇奇怪怪的代码结构就算了。
2，有深度：必须是三年到五年工作经验的工程师也觉得值得研究的问题。那种会出现在应届生面试现场的问题会被直接pass掉。 
3，可迁移：问题必须是产品无关，业务无关的。任何开发人员，无论是嵌入式开发，还是服务器开发都能用得上。部分问题甚至是跨系统的，在Linux和Windows上都同时成立。 经过以上标准的筛选，我一共选出了34个事故现场和7个救援现场，目录如下：

# 目录
第一章：工程与编译
1.1	extern关键字引发的数据读取失败
	主要内容：开发过程中，应当将extern视作一种禁忌。
1.2	静态库嵌套引用引发的符号表丢失
	主要内容：永远不要忽略编译期优化对项目结构的影响
1.3	aux_source_directory导致的平行引用异常
	主要内容：除非有十足的把握，否则不建议打破cmake的树形引用结构
1.4	cmake安全编译选项不完善导致的段错误崩溃
	主要内容：开发的任何阶段，都应当将安全编译选项全部开启。
1.5	作用域交叉引发的崩溃
	主要内容：作用域应当清晰明了，任何可能引起作用域交叉的编程风格都应当被禁止。
1.6	头文件中定义变量引发的内存膨胀
	主要内容：应当严格控制头文件中全局变量的尺寸
1.7	滥用宏定义导致的编译期错误日志混乱
	主要内容：应当将滥用宏定义视作一种陋习，予以最严厉的鄙视

第二章：函数与变量
2.1	数组中滥用多态引发的内存错位
	主要内容：不要在数组中存储多态对象，而是存储它们的指针
2.2	将符号数强转为带符号数，导致数字变得超大
	主要内容：应当将强制类型转换视作设计失败的标志。强制类型转换越多，设计越失败。
2.3	滥用全局变量导致的参数混乱
	主要内容：如果一个参数可以放在配置文件里，就不要写在代码里
2.4	内存释放前没有手动清零导致的数据泄漏
	主要内容：任何敏感内容，释放前必须手动清零
2.5	lambda表达式引发的智能指针引用计数异常
	主要内容：使用lambda时应当仅俘获必要数据，而不是图省事俘获全部数据。
2.6	递归引发的栈溢出
	主要内容：能用循环的地方就不要使用递归，应当将递归视作偷懒摸鱼的标志加以鄙视。
2.7	函数参数过多导致的效率下降
	主要内容：任何函数的参数都不应当超过5个

第三章：面向对象与容器
3.1	强制类型转换引发的成员函数寻址错误
	主要内容：除非有明确且充足的理由，否则应当禁止不同类型间的强制类型转换
3.2	智能指针管理数组对象引发的内存泄漏
	主要内容：不要使用智能指针管理数组对象，如果一定想用，就自己重载一个
3.3	普通指针和智能指针混用引发的内存二次释放
	主要内容：智能指针应当使用标准库提供的标准方法初始化，而不是使用new来初始化。
3.4	union数据类型引发的内存泄漏
	主要内容：永远不要假定union数据类型的长度
3.5	STL容器缺陷导致的段错误和崩溃
	主要内容：STL容器不是线程安全的
3.6	使用vector存放大规模数据引发的内存浪费
	主要内容：不要用数组类容器，存储大规模数据。也不要用节点类容器存储小规模数据。
3.7	使用数组容器存储敏感信息，导致的隐私泄漏事故
	主要内容：绝对禁止使用任何数组类容器存储敏感信息

第四章：多线程
4.1	condition variable引发的死锁
4.2	condition variable引发的虚假唤醒
4.3	condition variable中，wait的历史遗留问题，导致的退出时间计算错误
4.4	使用容器管理atomic变量导致原子性被破坏
	主要内容：使用数组类容器管理原子变量是没有意义的
4.5	管道通信，收发双方速率不一致导致的内存膨胀。
	主要内容：任何时候都要严格控制收发两端的协作节奏
4.6	跨部门权责交替导致的死锁
	主要内容：选择锁类型的时候，必须考虑线程从创建到销毁的全部生命周期。
4.7	进程池大小不足引发的死锁
	主要内容：进程池应当保证有重组的弹性，可以动态扩容。
4.8	滥用不可重入方法导致的死锁
	主要内容：任何方法使用前，都应当确定方法是否可重入
4.9	频繁开启和销毁线程引发的内存泄漏
	主要内容：任何时候都应当限制线程的数量，应当使用线程池管理线程，而不是每个业务自行创建线程。

第五章：计算机系统
5.1	gettimeofday函数引发的时间混乱
5.2	文件开启时权限不清晰导致的隐性提权
5.3	非持久目录导致的数据丢失
5.4	文件缓存导致的脏读取

第六章：经典救援案例纪实
6.1	锁异常导致现场线程死锁事故救援纪实
6.2	notify语句导致线程卡死事故救援纪实
6.3	进程异常段错误导致系统崩溃救援纪实
6.4	DLL丢失导致的系统崩溃救援纪实
6.5	内存膨胀事故救援纪实
6.6	内存不足导致的核心进程被OOM事故救援纪实
6.7	内存泄漏问题救援纪实


奋斗是一条漫长的道路，但也是唯一能让我们生而无憾的道路。立此文以明志，虽万难而无悔。